from collections.abc import Mapping
import typing
from . import (
    darwin,
    datemanip,
    mesh,
    perth,
    tidal_model,
)
from typing import ClassVar, overload

from ..type_hints import VectorDateTime64, VectorFloat64, VectorInt8

__all__ = [
    'AstronomicAngle',
    'Axis',
    'ConstituentMap',
    'FesRuntimeSettings',
    'Formulae',
    'InterpolationType',
    'PerthRuntimeSettings',
    'Settings',
    'TidalType',
    'darwin',
    'datemanip',
    'evaluate_tide',
    'mesh',
    'perth',
    'tidal_model',
]

FOURIER_ADMITTANCE: InterpolationType
IERS: Formulae
LINEAR_ADMITTANCE: InterpolationType
LONG_PERIOD: TidalType
MEEUS: Formulae
SCHUREMAN_ORDER_1: Formulae
SCHUREMAN_ORDER_3: Formulae
SHORT_PERIOD: TidalType
ZERO_ADMITTANCE: InterpolationType

class AstronomicAngle:
    def __init__(self, formulae: Formulae = ...) -> None: ...
    def update(self, date: object) -> None: ...
    @property
    def h(self) -> float: ...
    @property
    def i(self) -> float: ...
    @property
    def n(self) -> float: ...
    @property
    def nu(self) -> float: ...
    @property
    def nuprim(self) -> float: ...
    @property
    def nusec(self) -> float: ...
    @property
    def p(self) -> float: ...
    @property
    def p1(self) -> float: ...
    @property
    def r(self) -> float: ...
    @property
    def s(self) -> float: ...
    @property
    def t(self) -> float: ...
    @property
    def x1ra(self) -> float: ...
    @property
    def xi(self) -> float: ...

class Axis:
    def __init__(
        self,
        points: VectorFloat64,
        epsilon: typing.SupportsFloat = ...,
        is_circular: bool = ...,
    ) -> None: ...
    def end(self) -> float: ...
    def find_index(
        self, value: typing.SupportsFloat, bounded: bool = ...
    ) -> int: ...
    def find_indices(
        self, values: typing.SupportsFloat
    ) -> tuple[int, int] | None: ...
    def max_value(self) -> float: ...
    def min_value(self) -> float: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, index: typing.SupportsInt) -> float: ...
    def __len__(self) -> int: ...
    @property
    def is_ascending(self) -> bool: ...
    @property
    def is_circular(self) -> bool: ...
    @property
    def start(self) -> float: ...
    @property
    def step(self) -> float: ...

class ConstituentMap:
    def __init__(self, *args, **kwargs) -> None: ...
    def get(self, name: str, default: object = ...) -> object: ...
    def items(self) -> list[tuple[int, str]]: ...
    def keys(self) -> list[str]: ...
    def values(self) -> list[int]: ...
    def __contains__(self, name: str) -> bool: ...
    def __getitem__(self, name: str) -> int: ...
    def __len__(self) -> int: ...
    def __setitem__(self, value: typing.SupportsInt, name: str) -> None: ...

class FesRuntimeSettings(Settings):
    def __init__(self) -> None: ...

class Formulae:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    IERS: ClassVar[Formulae] = ...
    MEEUS: ClassVar[Formulae] = ...
    SCHUREMAN_ORDER_1: ClassVar[Formulae] = ...
    SCHUREMAN_ORDER_3: ClassVar[Formulae] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class InterpolationType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    FOURIER_ADMITTANCE: ClassVar[InterpolationType] = ...
    LINEAR_ADMITTANCE: ClassVar[InterpolationType] = ...
    ZERO_ADMITTANCE: ClassVar[InterpolationType] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PerthRuntimeSettings(Settings):
    def __init__(self) -> None: ...
    def with_group_modulations(self, group_modulations: bool) -> Settings: ...
    def with_inference_type(
        self, inference_type: InterpolationType
    ) -> Settings: ...
    @property
    def group_modulations(self) -> bool: ...
    @property
    def inference_type(self) -> InterpolationType: ...

class Settings:
    def __init__(self, *args, **kwargs) -> None: ...
    def with_astronomic_formulae(self, formulae: Formulae) -> Settings: ...
    def with_num_threads(self, num_threads: typing.SupportsInt) -> Settings: ...
    def with_time_tolerance(
        self, time_tolerance: typing.SupportsFloat
    ) -> Settings: ...
    @property
    def formulae(self) -> Formulae: ...
    @property
    def num_threads(self) -> int: ...
    @property
    def time_tolerance(self) -> float: ...

class TidalType:
    __members__: ClassVar[dict] = ...  # read-only
    __entries: ClassVar[dict] = ...
    kLongPeriod: ClassVar[TidalType] = ...
    kShortPeriod: ClassVar[TidalType] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

@overload
def evaluate_tide(
    tidal_model: tidal_model.AbstractTidalModelComplex128,
    date: VectorDateTime64,
    longitude: VectorFloat64,
    latitude: VectorFloat64,
    settings: Settings,
) -> tuple[VectorFloat64, VectorFloat64, VectorInt8]: ...
@overload
def evaluate_tide(
    tidal_model: tidal_model.AbstractTidalModelComplex64,
    date: VectorDateTime64,
    longitude: VectorFloat64,
    latitude: VectorFloat64,
    settings: Settings,
) -> tuple[VectorFloat64, VectorFloat64, VectorInt8]: ...
def evaluate_tide_from_constituents(
    constituents: Mapping[
        str, tuple[typing.SupportsFloat, typing.SupportsFloat]
    ],
    date: VectorDateTime64,
    latitude: typing.SupportsFloat,
    settings: Settings,
) -> tuple[VectorFloat64, VectorFloat64]: ...
