import collections.abc
import numpy
import numpy.typing
import typing
from typing import ClassVar, overload

from . import (
    darwin as darwin,
    perth as perth,
    tidal_model as tidal_model,
    mesh as mesh,
)

from ..type_hints import (
    MatrixComplex128,
    MatrixFloat64,
    VectorComplex128,
    VectorComplex64,
    VectorDateTime64,
    VectorFloat64,
    VectorInt8,
)

__all__ = [
    'DARWIN',
    'DEGREE',
    'DEGREE_PER_HOUR',
    'DOODSON',
    'FOURIER',
    'IERS',
    'LINEAR',
    'LONG_PERIOD',
    'MEEUS',
    'RADIAL',
    'RADIAN',
    'RADIAN_PER_HOUR',
    'SCHUREMAN_ORDER_1',
    'SCHUREMAN_ORDER_3',
    'SHORT_PERIOD',
    'SPLINE',
    'TIDE',
    'ZERO',
    'Accelerator',
    'AngleUnit',
    'AstronomicAngle',
    'Axis',
    'FESSettings',
    'Formulae',
    'FrequencyUnit',
    'InferenceType',
    'PerthSettings',
    'Settings',
    'TidalModelInterfaceComplex64',
    'TidalModelInterfaceComplex128',
    'TideType',
    'WaveInterface',
    'WaveTableInterface',
    'WaveType',
    'darwin',
    'evaluate_tide',
    'evaluate_tide_from_constituents',
    'generate_markdown_table',
    'known_constituents',
    'mesh',
    'parse_constituent',
    'perth',
    'tidal_model',
    'wave_table_factory',
]

DARWIN: EngineType
DEGREE: AngleUnit
DEGREE_PER_HOUR: FrequencyUnit
DOODSON: EngineType
FOURIER: InferenceType
IERS: Formulae
LINEAR: InferenceType
LONG_PERIOD: WaveType
MEEUS: Formulae
RADIAL: TideType
RADIAN: AngleUnit
RADIAN_PER_HOUR: FrequencyUnit
SCHUREMAN_ORDER_1: Formulae
SCHUREMAN_ORDER_3: Formulae
SHORT_PERIOD: WaveType
SPLINE: InferenceType
TIDE: TideType
ZERO: InferenceType

class Accelerator:
    def __init__(self, *args, **kwargs) -> None: ...

class AngleUnit:
    __members__: ClassVar[dict] = ...  # read-only
    DEGREE: ClassVar[AngleUnit] = ...
    RADIAN: ClassVar[AngleUnit] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class AstronomicAngle:
    def __init__(self, formulae: Formulae = ...) -> None: ...
    def update(self, date: object) -> None: ...
    @property
    def h(self) -> float: ...
    @property
    def i(self) -> float: ...
    @property
    def n(self) -> float: ...
    @property
    def nu(self) -> float: ...
    @property
    def nuprim(self) -> float: ...
    @property
    def nusec(self) -> float: ...
    @property
    def p(self) -> float: ...
    @property
    def p1(self) -> float: ...
    @property
    def r(self) -> float: ...
    @property
    def s(self) -> float: ...
    @property
    def t(self) -> float: ...
    @property
    def x1ra(self) -> float: ...
    @property
    def xi(self) -> float: ...

class Axis:
    def __init__(
        self,
        points: VectorFloat64,
        epsilon: typing.SupportsFloat = ...,
        is_periodic: bool = ...,
    ) -> None: ...
    def end(self) -> float: ...
    def find_index(
        self, value: typing.SupportsFloat, bounded: bool = ...
    ) -> int: ...
    def find_indices(
        self, values: typing.SupportsFloat
    ) -> tuple[int, int] | None: ...
    def max_value(self) -> float: ...
    def min_value(self) -> float: ...
    def __eq__(self, other: object) -> bool: ...
    def __getitem__(self, index: typing.SupportsInt) -> float: ...
    def __len__(self) -> int: ...
    @property
    def is_ascending(self) -> bool: ...
    @property
    def is_periodic(self) -> float: ...
    @property
    def start(self) -> float: ...
    @property
    def step(self) -> float: ...

class ConstituentValidationError(ValueError): ...

class EngineType:
    __members__: ClassVar[dict] = ...  # read-only
    DARWIN: ClassVar[EngineType] = ...
    DOODSON: ClassVar[EngineType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FESSettings(Settings):
    def __init__(self) -> None: ...

class Formulae:
    __members__: ClassVar[dict] = ...  # read-only
    IERS: ClassVar[Formulae] = ...
    MEEUS: ClassVar[Formulae] = ...
    SCHUREMAN_ORDER_1: ClassVar[Formulae] = ...
    SCHUREMAN_ORDER_3: ClassVar[Formulae] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class FrequencyUnit:
    __members__: ClassVar[dict] = ...  # read-only
    DEGREE_PER_HOUR: ClassVar[FrequencyUnit] = ...
    RADIAN_PER_HOUR: ClassVar[FrequencyUnit] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class LongPeriodEquilibrium:
    def __init__(self) -> None: ...
    def disable_dynamic_wave(self, wave_table: WaveTableInterface) -> None: ...
    def lpe_minus_n_waves(
        self, angles: AstronomicAngle, lat: typing.SupportsFloat
    ) -> float: ...

class InferenceType:
    __members__: ClassVar[dict] = ...  # read-only
    FOURIER: ClassVar[InferenceType] = ...
    LINEAR: ClassVar[InferenceType] = ...
    SPLINE: ClassVar[InferenceType] = ...
    ZERO: ClassVar[InferenceType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class PerthSettings(Settings):
    def __init__(self) -> None: ...

class Settings:
    astronomic_formulae: Formulae
    compute_long_period_equilibrium: bool
    engine_type: EngineType
    group_modulations: bool
    inference_type: InferenceType
    num_threads: int
    time_tolerance: float
    def __init__(self) -> None: ...
    def with_astronomic_formulae(self, formulae: Formulae) -> Settings: ...
    def with_compute_long_period_equilibrium(
        self, compute_long_period_equilibrium: bool
    ) -> Settings: ...
    def with_engine_type(self, engine_type: EngineType) -> Settings: ...
    def with_group_modulations(self, group_modulations: bool) -> Settings: ...
    def with_inference_type(
        self, inference_type: InferenceType
    ) -> Settings: ...
    def with_num_threads(self, num_threads: typing.SupportsInt) -> Settings: ...
    def with_time_tolerance(
        self, time_tolerance: typing.SupportsFloat
    ) -> Settings: ...

class TidalModelInterfaceComplex128:
    dynamic: list[str]
    def __init__(self, *args, **kwargs) -> None: ...
    def accelerator(
        self,
        formulae: Formulae = ...,
        time_tolerance: typing.SupportsFloat = ...,
    ) -> Accelerator: ...
    def add_constituent(self, name: str, wave: VectorComplex128) -> None: ...
    def clear(self) -> None: ...
    def identifiers(self) -> list[str]: ...
    def interpolate(
        self,
        lon: VectorFloat64,
        lat: VectorFloat64,
        num_threads: typing.SupportsInt = ...,
    ) -> tuple[dict[str, VectorComplex128], VectorInt8]: ...
    def memory_usage(self) -> int: ...
    def wave_table(
        self, engine_type: EngineType = ...
    ) -> WaveTableInterface: ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    @property
    def tide_type(self) -> TideType: ...

class TidalModelInterfaceComplex64:
    dynamic: list[str]
    def __init__(self, *args, **kwargs) -> None: ...
    def accelerator(
        self,
        formulae: Formulae = ...,
        time_tolerance: typing.SupportsFloat = ...,
    ) -> Accelerator: ...
    def add_constituent(self, name: str, wave: VectorComplex64) -> None: ...
    def clear(self) -> None: ...
    def identifiers(self) -> list[str]: ...
    def interpolate(
        self,
        lon: VectorFloat64,
        lat: VectorFloat64,
        num_threads: typing.SupportsInt = ...,
    ) -> tuple[dict[str, VectorComplex128], VectorInt8]: ...
    def memory_usage(self) -> int: ...
    def wave_table(
        self, engine_type: EngineType = ...
    ) -> WaveTableInterface: ...
    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    @property
    def tide_type(self) -> TideType: ...

class TideType:
    __members__: ClassVar[dict] = ...  # read-only
    RADIAL: ClassVar[TideType] = ...
    TIDE: ClassVar[TideType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class WaveInterface:
    is_modeled: bool
    tide: complex
    def compute_nodal_corrections(
        self, angles: AstronomicAngle, group_modulations: bool = ...
    ) -> None: ...
    def doodson_numbers(self) -> VectorInt8: ...
    def frequency(self, unit: FrequencyUnit = ...) -> float: ...
    def set_nodal_corrections(
        self,
        f: typing.SupportsFloat,
        u: typing.SupportsFloat,
        v: typing.SupportsFloat,
        unit: AngleUnit,
    ) -> None: ...
    def xdo_alphabetical(self) -> str: ...
    def xdo_numerical(self) -> str: ...
    @property
    def corrected_tide(self) -> float: ...
    @property
    def f(self) -> float: ...
    @property
    def latex_name(self) -> str: ...
    @property
    def name(self) -> str: ...
    @property
    def period(self) -> float: ...
    @property
    def type(self) -> WaveType: ...
    @property
    def u(self) -> float: ...
    @property
    def v(self) -> float: ...
    @property
    def vu(self) -> float: ...

class WaveTableInterface:
    def compute_nodal_corrections(
        self, angles: AstronomicAngle, group_modulations: bool = ...
    ) -> None: ...
    def compute_nodal_modulations(
        self,
        epoch: numpy.ndarray,
        formulae: Formulae = ...,
        group_modulations: bool = ...,
    ) -> tuple[
        typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]'],
        typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]'],
    ]: ...
    def generate_markdown_table(self, ascending: bool = ...) -> str: ...
    @staticmethod
    def harmonic_analysis(
        h: MatrixFloat64, f: MatrixFloat64, vu: MatrixFloat64
    ) -> VectorComplex128: ...
    def select_waves_for_analysis(
        self,
        duration: typing.SupportsFloat,
        rayleigh_criterion: typing.SupportsFloat = ...,
    ) -> list[str]: ...
    def set_modeled_constituents(
        self, names: collections.abc.Sequence[str]
    ) -> None: ...
    def set_tide(self, name: str, value: complex) -> None: ...
    def tide_from_mapping(
        self,
        epoch: object,
        wave: MatrixComplex128,
        formulae: Formulae = ...,
        group_modulations: bool = ...,
        num_threads: typing.SupportsInt = ...,
    ) -> typing.Annotated[numpy.typing.NDArray[numpy.float64], '[m, n]']: ...
    def tide_from_tide_series(
        self,
        epoch: numpy.ndarray,
        wave: VectorComplex128,
        formulae: Formulae = ...,
        group_modulations: bool = ...,
    ) -> VectorFloat64: ...
    def waves(self) -> list[WaveInterface]: ...
    def __contains__(self, name: str) -> bool: ...
    @overload
    def __getitem__(self, name: str) -> WaveInterface: ...
    @overload
    def __getitem__(self, index: typing.SupportsInt) -> WaveInterface: ...
    def __iter__(self) -> typing.Iterator[WaveInterface]: ...
    def __len__(self) -> int: ...
    @property
    def constituents(self) -> list[str]: ...

class WaveType:
    __members__: ClassVar[dict] = ...  # read-only
    LONG_PERIOD: ClassVar[WaveType] = ...
    SHORT_PERIOD: ClassVar[WaveType] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: typing.SupportsInt) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

def evaluate_equilibrium_long_period(
    dates: VectorDateTime64,
    latitudes: VectorFloat64,
    constituents: collections.abc.Sequence[str],
    settings: Settings | None = ...,
) -> VectorFloat64: ...
@overload
def evaluate_tide(
    tidal_model: TidalModelInterfaceComplex128,
    date: VectorDateTime64,
    longitude: VectorFloat64,
    latitude: VectorFloat64,
    settings: Settings | None = ...,
) -> tuple[VectorFloat64, VectorFloat64, VectorInt8]: ...
@overload
def evaluate_tide(
    tidal_model: TidalModelInterfaceComplex64,
    date: VectorDateTime64,
    longitude: VectorFloat64,
    latitude: VectorFloat64,
    settings: Settings | None = ...,
) -> tuple[VectorFloat64, VectorFloat64, VectorInt8]: ...
def evaluate_tide_from_constituents(
    constituents: collections.abc.Mapping[
        str, tuple[typing.SupportsFloat, typing.SupportsFloat]
    ],
    date: VectorDateTime64,
    latitude: typing.SupportsFloat,
    settings: Settings | None = ...,
) -> tuple[VectorFloat64, VectorFloat64]: ...
def generate_markdown_table(
    settings: Settings,
    ascending: bool = ...,
    modeled_constituents: collections.abc.Sequence[str] = ...,
) -> str: ...
def known_constituents() -> list[str]: ...
def parse_constituent(name: str) -> int: ...
def wave_table_factory(
    engine_type: EngineType = ...,
    constituents: collections.abc.Sequence[str] | None = ...,
) -> WaveTableInterface: ...
